{"version":3,"file":"vue.js","sources":["../src/init.js","../src/index.js"],"sourcesContent":["// import { initState } from './state';\n// import {compileToFunctions} from './compiler/index.js';\n// import {mountComponent, callHook} from './lifecycle.js'\n// import { mergeOptions } from './utils';\nexport function initMixin(Vue) {\ndebugger\n    Vue.prototype._init = function(options) {\n        // Vue的内部 $options 就是用户传递的所有参数\n        // const vm = this;\n        // // 这个options 就包含了用户创建实例时传入的所有属性 Vue.options\n        // vm.$options = mergeOptions(vm.constructor.options,options); // 用户传入的参数\n\n        // callHook(vm,'beforeCreate')\n        // initState(vm); // 初始化状态\n\n        // callHook(vm,'created')\n        // // 需要通过模板进行渲染\n        // if (vm.$options.el) { // 用户传入了el属性\n        //     vm.$mount(vm.$options.el)\n        // }\n    }\n    // Vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象\n    //     const vm = this;\n    //     el = vm.$el = document.querySelector(el); // 获取el属性\n\n    //     // 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\n    //     const opts = vm.$options;\n\n    //     if(!opts.render){\n    //         let template = opts.template;\n    //         if(!template && el){ // 应该使用外部的模板\n    //             template = el.outerHTML;\n    //             console.log(template)\n    //         }\n    //         const render = compileToFunctions(template);\n    //         opts.render = render;\n    //     }\n\n    //     // 走到这里说明不需要编译了 ，因为用户传入的就是 一个render函数\n\n    //     mountComponent(vm,el); // 组件的挂载流程\n    // }\n\n}\n\n","import {initMixin} from './init'; //给vue混入一个_init方法(模块化)\n// import {renderMixin} from './render.js';\n// import {lifeCycleMixin} from './lifecycle';\n// import {initGlobalAPI} from './global-api/index.js'\n// import { nextTick } from './observer/scheduler';\nfunction Vue(options){\n    debugger\n    // 内部要进行初始化的操作\n    this._init(options); // 初始化操作\n}\ndebugger\ninitMixin(Vue); // 添加原型的方法\n// renderMixin(Vue);\n// lifeCycleMixin(Vue);\n\n\n// // initGlobalApi 给构造函数来扩展全局的方法\n// initGlobalAPI(Vue);\n// Vue.prototype.$nextTick = nextTick\n\n\n\n// // ----------------------diff----------------------------\n// // diff 是比较两个树的差异 （虚拟dom）  把前后的dom节点渲染成虚拟dom，通过虚拟节点比对,找到差异，更新真实dom节点\n// import {compileToFunctions} from './compiler/index';\n// import {createElm,patch} from './vdom/patch'\n// let vm1 = new Vue({data:{name:'zf'}});\n// let vm2 = new Vue({data:{name:'jw'}});\n\n// let render1 = compileToFunctions(`<div>\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n// </div>`);\n// let oldVnode = render1.call(vm1);\n\n// let realElement = createElm(oldVnode);\n// document.body.appendChild(realElement);\n\n\n// let render2 = compileToFunctions(`<div>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//     <li key=\"M\">M</li>\n//     <li key=\"E\">E</li>\n// </div>`);\n// let newVnode = render2.call(vm2);\n// // 没有虚拟dom 和 diff算法时  直接重新渲染 强制重新更新页面（没有复用老的节点），\n// // diff 算法 而是先不对差异 在进行更新\n// setTimeout(() => {\n\n\n//     patch(oldVnode,newVnode); // 虚拟节点之间的比对\n// }, 1000);\n\n\n\n\nexport default Vue;"],"names":["initMixin","Vue","prototype","_init","options"],"mappings":";;;;;;IAAA;IACA;IACA;IACA;IACO,SAASA,SAAT,CAAmBC,GAAnB,EAAwB;IAC/B;;IACIA,EAAAA,GAAG,CAACC,SAAJ,CAAcC,KAAd,GAAsB,UAASC,OAAT,EAAkB,EAAlB;IAElB;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEJ;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IACA;IAnCA;IAqCH;;IC1CD;IACA;IACA;IACA;;IACA,SAASH,GAAT,CAAaG,OAAb,EAAqB;IACjB,WADiB;;IAGjB,OAAKD,KAAL,CAAWC,OAAX,EAHiB;;IAIpB;;IACD;IACAJ,SAAS,CAACC,GAAD,CAAT;;;;;;;;"}